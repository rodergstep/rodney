{"version":3,"names":[],"mappings":"","sources":["vendors/slideshow.js"],"sourcesContent":["if (document.querySelector('.slideshow')) {\n  // From http://www.quirksmode.org/js/events_properties.html#position\n  // Get the mouse position.\n  const getMousePos = e => {\n    let posx = 0;\n    let posy = 0;\n    if (!e) e = window.event;\n    if (e.pageX || e.pageY) {\n      posx = e.pageX;\n      posy = e.pageY;\n    } else if (e.clientX || e.clientY) {\n      posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n      posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n    }\n    return { x: posx, y: posy };\n  };\n  // Gets a random integer.\n  const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n  // Equation of a line (y = mx + b ).\n  const lineEq = (y2, y1, x2, x1, currentVal) => {\n    const m = (y2 - y1) / (x2 - x1);\n    const b = y1 - m * x1;\n    return m * currentVal + b;\n  };\n\n  // Some random chars.\n  const chars = [\n    '$',\n    '%',\n    '#',\n    '&',\n    '=',\n    '*',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n    'g',\n    'h',\n    'i',\n    'j',\n    'k',\n    'l',\n    'm',\n    'n',\n    'o',\n    'p',\n    'q',\n    'r',\n    's',\n    't',\n    'u',\n    'v',\n    'w',\n    'x',\n    'y',\n    'z',\n    '.',\n    ':',\n    ',',\n    '^',\n  ];\n  const charsTotal = chars.length;\n\n  // Randomize letters function. Used when navigating the slideshow to switch the curretn slide´s texts.\n  const randomizeLetters = letters => {\n    return new Promise((resolve, reject) => {\n      const lettersTotal = letters.length;\n      let cnt = 0;\n\n      letters.forEach((letter, pos) => {\n        let loopTimeout;\n        const loop = () => {\n          letter.innerHTML = chars[getRandomInt(0, charsTotal - 1)];\n          loopTimeout = setTimeout(loop, getRandomInt(50, 500));\n        };\n        loop();\n\n        const timeout = setTimeout(\n          () => {\n            clearTimeout(loopTimeout);\n            letter.style.opacity = 1;\n            letter.innerHTML = letter.dataset.initial;\n            ++cnt;\n            if (cnt === lettersTotal) {\n              resolve();\n            }\n          },\n          pos * lineEq(40, 0, 8, 200, lettersTotal),\n        );\n      });\n    });\n  };\n\n  // Hide each of the letters with random delays. Used when showing the current slide´s content.\n  const disassembleLetters = letters => {\n    return new Promise((resolve, reject) => {\n      const lettersTotal = letters.length;\n      let cnt = 0;\n\n      letters.forEach((letter, pos) => {\n        setTimeout(\n          () => {\n            letter.style.opacity = 0;\n            ++cnt;\n            if (cnt === lettersTotal) {\n              resolve();\n            }\n          },\n          pos * 30,\n        );\n      });\n    });\n  };\n\n  // The Slide class.\n  class Slide {\n    constructor(el) {\n      this.DOM = { el: el };\n      // The image wrap element.\n      this.DOM.imgWrap = this.DOM.el.querySelector('.slide__img-wrap');\n      // The image element.\n      this.DOM.img = this.DOM.imgWrap.querySelector('.slide__img');\n      // The texts: the parent wrap, title and side text.\n      this.DOM.texts = {\n        wrap: this.DOM.el.querySelector('.slide__title-wrap'),\n        title: this.DOM.el.querySelector('.slide__title'),\n        side: this.DOM.el.querySelector('.slide__side'),\n      };\n      // Split the title and side texts into spans, one per letter. Sort these so we can later animate then with the\n      // randomizeLetters or disassembleLetters functions when navigating and showing the content.\n      charming(this.DOM.texts.title);\n      charming(this.DOM.texts.side);\n      this.DOM.titleLetters = Array\n        .from(this.DOM.texts.title.querySelectorAll('span'))\n        .sort(() => 0.5 - Math.random());\n      this.DOM.sideLetters = Array\n        .from(this.DOM.texts.side.querySelectorAll('span'))\n        .sort(() => 0.5 - Math.random());\n      this.DOM.titleLetters.forEach(letter => letter.dataset.initial = letter.innerHTML);\n      this.DOM.sideLetters.forEach(letter => letter.dataset.initial = letter.innerHTML);\n      // Calculate the sizes of the image wrap.\n      this.calcSizes();\n      // And also the transforms needed per position.\n      // We have 5 different possible positions for a slide: center, bottom right, top left and outside the viewport (top left or bottom right).\n      this.calcTransforms();\n      // Init/Bind events.\n      this.initEvents();\n    }\n    // Gets the size of the image wrap.\n    calcSizes() {\n      this.width = this.DOM.imgWrap.offsetWidth;\n      this.height = this.DOM.imgWrap.offsetHeight;\n    }\n    // Gets the transforms per slide position.\n    calcTransforms() {\n      /*\n            Each position corresponds to the position of a given slide:\n            0: left top corner outside the viewport\n            1: left top corner (prev slide position)\n            2: center (current slide position)\n            3: right bottom corner (next slide position)\n            4: right bottom corner outside the viewport\n            5: left side, for when the content is shown\n            */\n      this.transforms = [\n        {\n          x: (-1) * (winsize.width / 2 + this.width),\n          y: (-1) * (winsize.height / 2 + this.height),\n          rotation: -30,\n        },\n        {\n          x: (-1) * (winsize.width / 2 - this.width / 3),\n          y: (-1) * (winsize.height / 2 - this.height / 3),\n          rotation: 0,\n        },\n        { x: 0, y: 0, rotation: 0 },\n        {\n          x: winsize.width / 2 - this.width / 3,\n          y: winsize.height / 2 - this.height / 3,\n          rotation: 0,\n        },\n        { x: winsize.width / 2 + this.width, y: winsize.height / 2 + this.height, rotation: 30 },\n        {\n          x: (-1) * (winsize.width / 2 - this.width / 2 - winsize.width * 0.075),\n          y: 0,\n          rotation: 0,\n        },\n      ];\n    }\n    // Init events:\n    // Mouseevents for mousemove/tilt/scale on the current image, and window resize.\n    initEvents() {\n      this.mouseenterFn = () => {\n        if (!this.isPositionedCenter() || !allowTilt) return;\n        clearTimeout(this.mousetime);\n        this.mousetime = setTimeout(\n          () => {\n            // Scale the image.\n            TweenMax.to(this.DOM.img, 0.8, { ease: Power3.easeOut, scale: 1.1 });\n          },\n          40,\n        );\n      };\n      this.mousemoveFn = ev => requestAnimationFrame(() => {\n        // Tilt the current slide.\n        if (!allowTilt || !this.isPositionedCenter()) return;\n        this.tilt(ev);\n      });\n      this.mouseleaveFn = ev => requestAnimationFrame(() => {\n        if (!allowTilt || !this.isPositionedCenter()) return;\n        clearTimeout(this.mousetime);\n\n        // Reset tilt and image scale.\n        TweenMax.to([ this.DOM.imgWrap, this.DOM.texts.wrap ], 1.8, {\n          ease: 'Power4.easeOut',\n          x: 0,\n          y: 0,\n          rotationX: 0,\n          rotationY: 0,\n        });\n        TweenMax.to(this.DOM.img, 1.8, { ease: 'Power4.easeOut', scale: 1 });\n      });\n      // When resizing the window recalculate size and transforms, since both will depend on the window size.\n      this.resizeFn = () => {\n        this.calcSizes();\n        this.calcTransforms();\n      };\n      this.DOM.imgWrap.addEventListener('mouseenter', this.mouseenterFn);\n      this.DOM.imgWrap.addEventListener('mousemove', this.mousemoveFn);\n      this.DOM.imgWrap.addEventListener('mouseleave', this.mouseleaveFn);\n      window.addEventListener('resize', this.resizeFn);\n    }\n    // Tilt the image wrap and texts when mouse moving the current slide.\n    tilt(ev) {\n      const mousepos = getMousePos(ev);\n      // Document scrolls.\n      const docScrolls = {\n        left: document.body.scrollLeft + document.documentElement.scrollLeft,\n        top: document.body.scrollTop + document.documentElement.scrollTop,\n      };\n      const bounds = this.DOM.imgWrap.getBoundingClientRect();\n      // Mouse position relative to the main element (this.DOM.el).\n      const relmousepos = {\n        x: mousepos.x - bounds.left - docScrolls.left,\n        y: mousepos.y - bounds.top - docScrolls.top,\n      };\n\n      // Move the element from -20 to 20 pixels in both x and y axis.\n      // Rotate the element from -15 to 15 degrees in both x and y axis.\n      let t = { x: [ -20, 20 ], y: [ -20, 20 ] }, r = { x: [ -15, 15 ], y: [ -15, 15 ] };\n\n      const transforms = {\n        translation: {\n          x: (t.x[1] - t.x[0]) / bounds.width * relmousepos.x + t.x[0],\n          y: (t.y[1] - t.y[0]) / bounds.height * relmousepos.y + t.y[0],\n        },\n        rotation: {\n          x: (r.x[1] - r.x[0]) / bounds.height * relmousepos.y + r.x[0],\n          y: (r.y[1] - r.y[0]) / bounds.width * relmousepos.x + r.y[0],\n        },\n      };\n\n      // Move the image wrap.\n      TweenMax.to(this.DOM.imgWrap, 1.5, {\n        ease: 'Power1.easeOut',\n        x: transforms.translation.x,\n        y: transforms.translation.y,\n        rotationX: transforms.rotation.x,\n        rotationY: transforms.rotation.y,\n      });\n\n      // Move the texts wrap.\n      TweenMax.to(this.DOM.texts.wrap, 1.5, {\n        ease: 'Power1.easeOut',\n        x: (-1) * transforms.translation.x,\n        y: (-1) * transforms.translation.y,\n      });\n    }\n    // Positions one slide (left, right or current) in the viewport.\n    position(pos) {\n      TweenMax.set(this.DOM.imgWrap, {\n        x: this.transforms[pos].x,\n        y: this.transforms[pos].y,\n        rotationX: 0,\n        rotationY: 0,\n        opacity: 0.3,\n        filter: 'grayscale(0)',\n        rotationZ: this.transforms[pos].rotation,\n      });\n    }\n    // Sets it as current.\n    setCurrent(isContentOpen) {\n      this.isCurrent = true;\n      this.DOM.el.classList.add('slide--current', 'slide--visible');\n      // Position it on the current´s position.\n      this.position(isContentOpen ? 5 : 2);\n    }\n    // Position the slide on the left side.\n    setLeft(isContentOpen) {\n      this.isRight = this.isCurrent = false;\n      this.isLeft = true;\n      this.DOM.el.classList.add('slide--visible');\n      // Position it on the left position.\n      this.position(isContentOpen ? 0 : 1);\n    }\n    // Position the slide on the right side.\n    setRight(isContentOpen) {\n      this.isLeft = this.isCurrent = false;\n      this.isRight = true;\n      this.DOM.el.classList.add('slide--visible');\n      // Position it on the right position.\n      this.position(isContentOpen ? 4 : 3);\n    }\n    // Check if the slide is positioned on the right side (if it´s the next slide in the slideshow).\n    isPositionedRight() {\n      return this.isRight;\n    }\n    // Check if the slide is positioned on the left side (if it´s the previous slide in the slideshow).\n    isPositionedLeft() {\n      return this.isLeft;\n    }\n    // Check if the slide is the current one.\n    isPositionedCenter() {\n      return this.isCurrent;\n    }\n    // Reset classes and state.\n    reset() {\n      this.isRight = this.isLeft = this.isCurrent = false;\n      this.DOM.el.classList = 'slide';\n    }\n    hide() {\n      TweenMax.set(this.DOM.imgWrap, {\n        x: 0,\n        y: 0,\n        rotationX: 0,\n        rotationY: 0,\n        rotationZ: 0,\n        opacity: 0,\n      });\n    }\n    // Moves a slide to a specific position defined in settings.position.\n    // Also, moves it from position settings.from and if we need to reset the image scale when moving the slide then settings.resetImageScale should be true.\n    moveToPosition(settings) {\n      return new Promise((resolve, reject) => {\n        /*\n                Moves the slide to a specific position:\n                -2: left top corner outside the viewport\n                -1: left top corner (prev slide position)\n                0: center (current slide position)\n                1: right bottom corner (next slide position)\n                2: right bottom corner outside the viewport\n                3: left side, for when the content is shown\n                */\n        TweenMax.to(this.DOM.imgWrap, .8, {\n          ease: Power4.easeInOut,\n          delay: settings.delay || 0,\n          startAt: settings.from !== undefined\n            ? {\n              x: this.transforms[settings.from + 2].x,\n              y: this.transforms[settings.from + 2].y,\n              rotationX: 0,\n              rotationY: 0,\n              rotationZ: this.transforms[settings.from + 2].rotation,\n            }\n            : {},\n          x: this.transforms[settings.position + 2].x,\n          y: this.transforms[settings.position + 2].y,\n          rotationX: 0,\n          rotationY: 0,\n          rotationZ: this.transforms[settings.position + 2].rotation,\n          opacity: 1,\n          onStart: settings.from !== undefined\n            ? () => TweenMax.set(this.DOM.imgWrap, { opacity: 0.3, filter: 'grayscale(1)' })\n            : null,\n          onComplete: resolve,\n        });\n\n        // Reset image scale when showing the content of the current slide.\n        if (settings.resetImageScale) {\n          TweenMax.to(this.DOM.img, .8, { ease: Power4.easeInOut, scale: 1 });\n        }\n      });\n    }\n    // Hides the current slide´s texts.\n    hideTexts(animation = false) {\n      if (animation) {\n        disassembleLetters(\n          this.DOM.titleLetters,\n        ).then(() => TweenMax.set(this.DOM.texts.wrap, { opacity: 0 }));\n        disassembleLetters(\n          this.DOM.sideLetters,\n        ).then(() => TweenMax.set(this.DOM.texts.side, { opacity: 0 }));\n      } else {\n        TweenMax.set(this.DOM.texts.wrap, { opacity: 0 });\n        TweenMax.set(this.DOM.texts.side, { opacity: 0 });\n      }\n    }\n    // Shows the current slide´s texts.\n    showTexts(animation = true) {\n      TweenMax.set(this.DOM.texts.wrap, { opacity: 1 });\n      TweenMax.set(this.DOM.texts.side, { opacity: 1 });\n\n      if (animation) {\n        randomizeLetters(this.DOM.titleLetters);\n        randomizeLetters(this.DOM.sideLetters);\n      }\n    }\n  }\n\n  // The Content class. Represents one content item per slide.\n  class Content {\n    constructor(el) {\n      this.DOM = { el: el };\n      this.DOM.title = this.DOM.el.querySelector('.content__title');\n      this.DOM.subtitle = this.DOM.el.querySelector('.content__subtitle');\n      this.DOM.text = this.DOM.el.querySelector('.content__text');\n      this.DOM.backCtrl = this.DOM.el.parentNode.querySelector('.content__close');\n      this.DOM.backCtrl.addEventListener('click', () => slideshow.hideContent());\n    }\n    show() {\n      this.DOM.el.classList.add('content__item--current');\n\n      TweenMax.staggerTo(\n        [ this.DOM.backCtrl, this.DOM.title, this.DOM.subtitle, this.DOM.text ],\n        0.8,\n        { ease: Power4.easeOut, delay: 0.4, opacity: 1, startAt: { y: 40 }, y: 0 },\n        0.05,\n      );\n    }\n    hide() {\n      this.DOM.el.classList.remove('content__item--current');\n\n      TweenMax.staggerTo(\n        [ this.DOM.backCtrl, this.DOM.title, this.DOM.subtitle, this.DOM.text ].reverse(),\n        0.3,\n        { ease: Power3.easeIn, opacity: 0, y: 10 },\n        0.01,\n      );\n    }\n  }\n\n  // The Slideshow class.\n  class Slideshow {\n    constructor(el) {\n      this.DOM = { el: el };\n      // The slides.\n      this.slides = [];\n      Array\n        .from(this.DOM.el.querySelectorAll('.slide'))\n        .forEach(slideEl => this.slides.push(new Slide(slideEl)));\n      // The total number of slides.\n      this.slidesTotal = this.slides.length;\n      // At least 4 slides to continue...\n      if (this.slidesTotal < 4) {\n        return false;\n      }\n      // Current slide position.\n      this.current = 0;\n      this.DOM.deco = this.DOM.el.querySelector('.slideshow__deco');\n\n      this.contents = [];\n      Array\n        .from(document.querySelectorAll('.content > .content__item'))\n        .forEach(contentEl => this.contents.push(new Content(contentEl)));\n\n      // Set the current/next/previous slides.\n      this.render();\n      this.currentSlide.showTexts(false);\n      // Init/Bind events.\n      this.initEvents();\n    }\n    render() {\n      // The current, next, and previous slides.\n      this.currentSlide = this.slides[this.current];\n      this.nextSlide = this.slides[this.current + 1 <= this.slidesTotal - 1 ? this.current + 1 : 0];\n      this.prevSlide = this.slides[this.current - 1 >= 0 ? this.current - 1 : this.slidesTotal - 1];\n      this.currentSlide.setCurrent();\n      this.nextSlide.setRight();\n      this.prevSlide.setLeft();\n    }\n    initEvents() {\n      // Clicking the next and previous slide starts the navigation / clicking the current shows its content..\n      this.clickFn = slide => {\n        if (slide.isPositionedRight()) {\n          this.navigate('next');\n        } else if (slide.isPositionedLeft()) {\n          this.navigate('prev');\n        } else {\n          this.showContent();\n        }\n      };\n      for (let slide of this.slides) {\n        slide.DOM.imgWrap.addEventListener('click', () => this.clickFn(slide));\n      }\n\n      this.resizeFn = () => {\n        // Reposition the slides.\n        this.nextSlide.setRight(this.isContentOpen);\n        this.prevSlide.setLeft(this.isContentOpen);\n        this.currentSlide.setCurrent(this.isContentOpen);\n\n        if (this.isContentOpen) {\n          TweenMax.set(this.DOM.deco, {\n            scaleX: winsize.width / this.DOM.deco.offsetWidth,\n            scaleY: winsize.height / this.DOM.deco.offsetHeight,\n            x: -20,\n            y: 0,\n          });\n        }\n      };\n      window.addEventListener('resize', this.resizeFn);\n    }\n    showContent() {\n      if (this.isContentOpen || this.isAnimating) return;\n      allowTilt = false;\n      this.isContentOpen = true;\n      this.DOM.el.classList.add('slideshow--previewopen');\n      document.querySelector('body').classList.add('header--white');\n      TweenMax.to(this.DOM.deco, .8, {\n        ease: Power4.easeInOut,\n        scaleX: winsize.width / this.DOM.deco.offsetWidth,\n        scaleY: winsize.height / this.DOM.deco.offsetHeight,\n        x: -20,\n        y: 0,\n      });\n      // Move away right/left slides.\n      this.prevSlide.moveToPosition({ position: -2 });\n      this.nextSlide.moveToPosition({ position: 2 });\n      // Position the current slide and reset its image scale value.\n      this.currentSlide.moveToPosition({ position: 3, resetImageScale: true });\n      // Show content and back arrow (to close the content).\n      this.contents[this.current].show();\n      // Hide texts.\n      this.currentSlide.hideTexts(true);\n    }\n    hideContent() {\n      if (!this.isContentOpen || this.isAnimating) return;\n\n      this.DOM.el.classList.remove('slideshow--previewopen');\n      document.querySelector('body').classList.remove('header--white');\n\n      // Hide content.\n      this.contents[this.current].hide();\n\n      TweenMax.to(this.DOM.deco, .8, { ease: Power4.easeInOut, scaleX: 1, scaleY: 1, x: 0, y: 0 });\n      // Move in right/left slides.\n      this.prevSlide.moveToPosition({ position: -1 });\n      this.nextSlide.moveToPosition({ position: 1 });\n      // Position the current slide.\n      this.currentSlide.moveToPosition({ position: 0 }).then(() => {\n        allowTilt = true;\n        this.isContentOpen = false;\n      });\n      // Show texts.\n      this.currentSlide.showTexts();\n    }\n    // Animates the element behind the current slide.\n    bounceDeco(direction, delay) {\n      TweenMax.to(this.DOM.deco, .4, {\n        ease: 'Power2.easeIn',\n        delay: delay + delay * 0.2,\n        x: direction === 'next' ? -40 : 40,\n        y: direction === 'next' ? -40 : 40,\n        onComplete: () => {\n          TweenMax.to(this.DOM.deco, 0.6, {\n            //ease: Elastic.easeOut.config(1, 0.65),\n            ease: 'Power2.easeOut',\n            x: 0,\n            y: 0,\n          });\n        },\n      });\n    }\n    // Navigate the slideshow.\n    navigate(direction) {\n      // If animating return.\n      if (this.isAnimating) return;\n      this.isAnimating = true;\n      allowTilt = false;\n\n      const upcomingPos = direction === 'next'\n        ? this.current < this.slidesTotal - 2\n          ? this.current + 2\n          : Math.abs(this.slidesTotal - 2 - this.current)\n        : this.current >= 2 ? this.current - 2 : Math.abs(this.slidesTotal - 2 + this.current);\n\n      this.upcomingSlide = this.slides[upcomingPos];\n\n      // Update current.\n      this.current = direction === 'next'\n        ? this.current < this.slidesTotal - 1 ? this.current + 1 : 0\n        : this.current > 0 ? this.current - 1 : this.slidesTotal - 1;\n\n      // Move slides (the previous, current, next and upcoming slide).\n      this.prevSlide\n        .moveToPosition({\n          position: direction === 'next' ? -2 : 0,\n          delay: direction === 'next' ? 0 : 0.14,\n        })\n        .then(() => {\n          if (direction === 'next') {\n            this.prevSlide.hide();\n          }\n        });\n\n      this.currentSlide.moveToPosition({ position: direction === 'next' ? -1 : 1, delay: 0.07 });\n      this.currentSlide.hideTexts();\n\n      this.bounceDeco(direction, 0.07);\n\n      this.nextSlide\n        .moveToPosition({\n          position: direction === 'next' ? 0 : 2,\n          delay: direction === 'next' ? 0.14 : 0,\n        })\n        .then(() => {\n          if (direction === 'prev') {\n            this.nextSlide.hide();\n          }\n        });\n\n      if (direction === 'next') {\n        this.nextSlide.showTexts();\n      } else {\n        this.prevSlide.showTexts();\n      }\n\n      this.upcomingSlide\n        .moveToPosition({\n          position: direction === 'next' ? 1 : -1,\n          from: direction === 'next' ? 2 : -2,\n          delay: 0.21,\n        })\n        .then(() => {\n          // Reset classes.\n          [ this.nextSlide, this.currentSlide, this.prevSlide ].forEach(slide => slide.reset());\n          this.render();\n          allowTilt = true;\n          this.isAnimating = false;\n        });\n    }\n  }\n\n  // Window sizes.\n  let winsize;\n  const calcWinsize = () => winsize = { width: window.innerWidth, height: window.innerHeight };\n  calcWinsize();\n  window.addEventListener('resize', calcWinsize);\n\n  let allowTilt = true;\n\n  // Init slideshow.\n  const slideshow = new Slideshow(document.querySelector('.slideshow'));\n\n  // Preload all the images in the page..\n  const loader = document.querySelector('.loader');\n  imagesLoaded(\n    document.querySelectorAll('.slide__img'),\n    { background: true },\n    () => document.body.classList.remove('loading'),\n  );\n}\n"],"file":"slideshow.js"}